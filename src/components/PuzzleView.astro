---
import { getPuzzleMeta } from "../lib/puzzles";

type Props = {
  date: string;
  showDate?: boolean;
};

const { date, showDate = true } = Astro.props;
const base = import.meta.env.BASE_URL;

function formatPuzzleDate(dateStr: string): string {
  if (dateStr === "latest") return "Latest";
  const [y, m, d] = dateStr.split("-").map(Number);
  const safe = new Date(Date.UTC(y, m - 1, d, 12, 0, 0));
  return new Intl.DateTimeFormat("en-US", {
    month: "short",
    day: "numeric",
    year: "numeric",
    timeZone: "America/New_York",
  }).format(safe);
}

const meta = date === "latest" ? undefined : await getPuzzleMeta(date);
const title =
  meta?.title?.trim() ||
  (date === "latest"
    ? "Latest Puzzle"
    : `Puzzle for ${formatPuzzleDate(date)}`);
---

<section class="puzzle-view" aria-live="polite">
  <div class="puzzle-header text-center">
    <h1 id={`puzzle-title-${date}`}>{title}</h1>
    {showDate ? (
      <p class="puzzle-date" id={`puzzle-date-${date}`}>
        Date: <strong>{date}</strong>
      </p>
    ) : null}
  </div>

  <div id={`puzzle-content-${date}`} class="puzzle-content">
    <p>Loading puzzle...</p>
  </div>

  <div id={`qa-${date}`} class="qa"></div>

  <script define:vars={{ date, base }}>
    // Inline puzzle client logic (compiled from TypeScript)
    
    function escapeHtml(text) {
      return text
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    function applyInlineFormatting(text) {
      // **bold**
      text = text.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");

      // *italic* (avoid ** being treated as italics)
      text = text.replace(/(^|[^*])\*(?!\*)(.+?)\*(?!\*)/g, "$1<em>$2</em>");

      return text;
    }

    function renderRichTextLiteHtml(raw) {
      const s = String(raw ?? "");
      if (!s.trim()) return "";

      const normalized = s.replace(/\r\n/g, "\n");

      // Split into paragraphs on blank lines
      const paragraphs = normalized.split(/\n\s*\n/);

      return paragraphs
        .map((para) => {
          const escaped = escapeHtml(para);
          const formatted = applyInlineFormatting(escaped);
          const withLineBreaks = formatted.replace(/\n/g, "<br />");
          return `<p>${withLineBreaks}</p>`;
        })
        .join("\n");
    }

    function getUnlockedDateET(now) {
      const formatter = new Intl.DateTimeFormat("en-US", {
        timeZone: "America/New_York",
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
      });

      const parts = formatter.formatToParts(now);
      const year = parts.find((p) => p.type === "year")?.value;
      const month = parts.find((p) => p.type === "month")?.value;
      const day = parts.find((p) => p.type === "day")?.value;

      return `${year}-${month}-${day}`;
    }

    function clear(el) {
      while (el.firstChild) el.removeChild(el.firstChild);
    }

    function renderQA(container, data) {
      clear(container);

      const card = document.createElement("section");
      card.className = "qa-card";

      const q = document.createElement("h2");
      q.className = "qa-question";
      q.textContent = data.question || "Question";

      const optionsWrap = document.createElement("div");
      optionsWrap.className = "qa-options";
      optionsWrap.setAttribute("role", "group");
      optionsWrap.setAttribute("aria-label", "Answer options");

      const feedback = document.createElement("div");
      feedback.className = "qa-feedback";
      feedback.setAttribute("aria-live", "polite");

      const explanation = document.createElement("div");
      explanation.className = "qa-explanation";
      explanation.style.display = "none";

      let answered = false;
      const correctIndex = Number(data.answer) - 1;

      const buttons = (data.options || []).map((optText, idx) => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "qa-option";
        btn.textContent = String(optText);

        btn.addEventListener("click", () => {
          if (answered) return;
          answered = true;

          const isCorrect = idx === correctIndex;

          buttons.forEach((b, j) => {
            b.disabled = true;
            b.classList.add("is-locked");
            if (j === correctIndex) b.classList.add("is-correct");
            if (j === idx) b.classList.add("is-selected");
            if (j === idx && !isCorrect) b.classList.add("is-wrong");
          });

          feedback.textContent = isCorrect ? "Correct!" : "Not quite.";

          if (data.explanation && String(data.explanation).trim().length > 0) {
            explanation.style.display = "";

            clear(explanation);
            const h = document.createElement("h3");
            h.textContent = "Explanation";
            explanation.appendChild(h);

            const body = document.createElement("div");
            body.className = "qa-explanation-body";
            body.innerHTML = renderRichTextLiteHtml(data.explanation);
            explanation.appendChild(body);
          }
        });

        return btn;
      });

      optionsWrap.append(...buttons);
      card.append(q, optionsWrap, feedback, explanation);
      container.appendChild(card);
    }

    async function resolveLatestDate(base) {
      const res = await fetch(`${base}puzzles/manifest.json`, {
        cache: "no-store",
      });
      if (!res.ok) throw new Error("Manifest not found");
      const manifest = await res.json();

      const unlockedDate = getUnlockedDateET(new Date());
      const eligible = (Array.isArray(manifest) ? manifest : [])
        .map((p) => p?.date)
        .filter((d) => typeof d === "string" && d <= unlockedDate)
        .sort();

      return eligible.length ? eligible[eligible.length - 1] : null;
    }

    async function loadPuzzleClient(date, base) {
      let activeDate = date;
      if (activeDate === "latest") {
        try {
          const resolved = await resolveLatestDate(base);
          if (!resolved) {
            const puzzleEl = document.getElementById(`puzzle-content-${date}`);
            if (puzzleEl) {
              puzzleEl.innerHTML =
                "<p>No puzzles have been published yet.</p>";
            }
            return;
          }
          activeDate = resolved;

          const titleEl = document.getElementById(`puzzle-title-${date}`);
          if (titleEl) titleEl.textContent = `Puzzle for ${activeDate}`;

          const dateEl = document.getElementById(`puzzle-date-${date}`);
          if (dateEl) {
            dateEl.innerHTML = `Date: <strong>${activeDate}</strong>`;
          }
        } catch (e) {
          const puzzleEl = document.getElementById(`puzzle-content-${date}`);
          if (puzzleEl) {
            puzzleEl.innerHTML = "<p>Error loading puzzle.</p>";
          }
          console.error("Failed to load manifest:", e);
          return;
        }
      }

      const unlockedDate = getUnlockedDateET(new Date());
      if (activeDate > unlockedDate) {
        window.location.href = `${base}`;
        return;
      }

      const puzzleEl = document.getElementById(`puzzle-content-${date}`);
      const qaEl = document.getElementById(`qa-${date}`);
      if (!puzzleEl || !qaEl) return;

      try {
        const res = await fetch(`${base}puzzles/${activeDate}.json`, {
          cache: "no-store",
        });
        if (!res.ok) throw new Error("Puzzle not found");
        const data = await res.json();

        puzzleEl.innerHTML = renderRichTextLiteHtml(data.puzzle);
        renderQA(qaEl, data);
      } catch (e) {
        puzzleEl.innerHTML = "<p>Error loading puzzle.</p>";
        clear(qaEl);
        console.error("Failed to load puzzle:", e);
      }
    }

    // Execute
    loadPuzzleClient(date, base);
  </script>
</section>
